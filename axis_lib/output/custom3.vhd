---------------------------------------------------------------------------------------------------------
-- This code and it autogenerated outputs are provided under LGPL by Ricardo Tafas.                    --
-- What does that mean? That you get it for free as long as you give back all good stiff you add to it.--
-- You can download more VHDL stuff at https://github.com/rftafas                                      --
---------------------------------------------------------------------------------------------------------
library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;

entity axis_custom is
    generic (
      tdata_size   : integer := 8;
      tdest_size   : integer := 8;
      tuser_size   : integer := 8
    );
    port (
      clk_i       : in  std_logic;
      rst_i       : in  std_logic;
      --AXIS Slave Port 0
      s0_tdata_i  : in  std_logic_vector(tdata_size-1 downto 0);
      s0_tuser_i  : in  std_logic_vector(tuser_size-1 downto 0);
      s0_tdest_i  : in  std_logic_vector(tdest_size-1 downto 0);
      s0_tready_o : out std_logic;
      s0_tvalid_i : in  std_logic;
      s0_tlast_i  : in  std_logic;
      --AXIS Slave Port 1
      s1_tdata_i  : in  std_logic_vector(tdata_size-1 downto 0);
      s1_tuser_i  : in  std_logic_vector(tuser_size-1 downto 0);
      s1_tdest_i  : in  std_logic_vector(tdest_size-1 downto 0);
      s1_tready_o : out std_logic;
      s1_tvalid_i : in  std_logic;
      s1_tlast_i  : in  std_logic;
      --AXIS Slave Port 2
      s2_tdata_i  : in  std_logic_vector(tdata_size-1 downto 0);
      s2_tuser_i  : in  std_logic_vector(tuser_size-1 downto 0);
      s2_tdest_i  : in  std_logic_vector(tdest_size-1 downto 0);
      s2_tready_o : out std_logic;
      s2_tvalid_i : in  std_logic;
      s2_tlast_i  : in  std_logic;
      --AXIS Master Port 0
      m0_tdata_o    : out std_logic_vector(tdata_size-1 downto 0);
      m0_tuser_o    : out std_logic_vector(tuser_size-1 downto 0);
      m0_tdest_o    : out std_logic_vector(tdest_size-1 downto 0);
      m0_tready_i   : in  std_logic;
      m0_tvalid_o   : out std_logic;
      m0_tlast_o    : out std_logic;
      --AXIS Master Port 1
      m1_tdata_o    : out std_logic_vector(tdata_size-1 downto 0);
      m1_tuser_o    : out std_logic_vector(tuser_size-1 downto 0);
      m1_tdest_o    : out std_logic_vector(tdest_size-1 downto 0);
      m1_tready_i   : in  std_logic;
      m1_tvalid_o   : out std_logic;
      m1_tlast_o    : out std_logic;
      --AXIS Master Port 2
      m2_tdata_o    : out std_logic_vector(tdata_size-1 downto 0);
      m2_tuser_o    : out std_logic_vector(tuser_size-1 downto 0);
      m2_tdest_o    : out std_logic_vector(tdest_size-1 downto 0);
      m2_tready_i   : in  std_logic;
      m2_tvalid_o   : out std_logic;
      m2_tlast_o    : out std_logic;
      --Custom ports go here.
      example_port : in  std_logic
    );
end axis_custom;

architecture behavioral of custom3 is

  constant number_slaves  : integer := 3;
  constant number_masters : integer := 3;

  constant all1_c : std_logic_vector(number_ports-1 downto 0) := (others=>'1');

  type axi_tdata_array is array (natural range <>) of std_logic_vector(tdata_size-1 downto 0);
  type axi_tuser_array is array (natural range <>) of std_logic_vector(tuser_size-1 downto 0);
  type axi_tdest_array is array (natural range <>) of std_logic_vector(tdest_size-1 downto 0);

  signal s_tdata_s  :  axi_tdata_array(number_slaves-1 downto 0);
  signal s_tuser_s  :  axi_tuser_array(number_slaves-1 downto 0);
  signal s_tdest_s  :  axi_tdest_array(number_slaves-1 downto 0);
  signal s_tvalid_s : std_logic_vector(number_slaves-1 downto 0);
  signal s_tlast_s  : std_logic_vector(number_slaves-1 downto 0);
  signal s_tready_s : std_logic_vector(number_slaves-1 downto 0);

  signal m_tdata_s  :  axi_tdata_array(number_masters-1 downto 0);
  signal m_tuser_s  :  axi_tuser_array(number_masters-1 downto 0);
  signal m_tdest_s  :  axi_tdest_array(number_masters-1 downto 0);
  signal m_tvalid_s : std_logic_vector(number_masters-1 downto 0);
  signal m_tlast_s  : std_logic_vector(number_masters-1 downto 0);
  signal m_tready_s : std_logic_vector(number_masters-1 downto 0);

  --your custom signals go here.

begin

  --Master Connections
  --Master 0
  m0_tvalid_o <= m_tvalid_s(0);
  m0_tlast_o  <= m_tlast_s(0);
  m_tready_s(0) <= m0_tready_i;
  m0_tdata_o  <= m_tdata_s(0);
  m0_tuser_o  <= m_tuser_s(0);
  m0_tdest_o  <= m_tdest_s(0);
  
  --Master 1
  m1_tvalid_o <= m_tvalid_s(1);
  m1_tlast_o  <= m_tlast_s(1);
  m_tready_s(1) <= m1_tready_i;
  m1_tdata_o  <= m_tdata_s(1);
  m1_tuser_o  <= m_tuser_s(1);
  m1_tdest_o  <= m_tdest_s(1);
  
  --Master 2
  m2_tvalid_o <= m_tvalid_s(2);
  m2_tlast_o  <= m_tlast_s(2);
  m_tready_s(2) <= m2_tready_i;
  m2_tdata_o  <= m_tdata_s(2);
  m2_tuser_o  <= m_tuser_s(2);
  m2_tdest_o  <= m_tdest_s(2);
  
  --Slave Connections
  --Slave 0
  s_tvalid_s(0) <= s0_tvalid_i;
  s_tlast_s(0)  <= s0_tlast_i;
  s0_tready_o  <= s_tready_s(0);
  s_tdata_s(0)  <= s0_tdata_i;
  s_tuser_s(0)  <= s0_tuser_i;
  s_tdest_s(0)  <= s0_tdest_i;
  
  --Slave 1
  s_tvalid_s(1) <= s1_tvalid_i;
  s_tlast_s(1)  <= s1_tlast_i;
  s1_tready_o  <= s_tready_s(1);
  s_tdata_s(1)  <= s1_tdata_i;
  s_tuser_s(1)  <= s1_tuser_i;
  s_tdest_s(1)  <= s1_tdest_i;
  
  --Slave 2
  s_tvalid_s(2) <= s2_tvalid_i;
  s_tlast_s(2)  <= s2_tlast_i;
  s2_tready_o  <= s_tready_s(2);
  s_tdata_s(2)  <= s2_tdata_i;
  s_tuser_s(2)  <= s2_tuser_i;
  s_tdest_s(2)  <= s2_tdest_i;
  

-- your code goes here.
-- Make sure to use the following signals instead the ports:
-- s_tdata_s
-- s_tuser_s
-- s_tdest_s
-- s_tvalid_s
-- s_tlast_s
-- s_tready_s
-- m_tdata_s
-- m_tuser_s
-- m_tdest_s
-- m_tvalid_s
-- m_tlast_s
-- m_tready_s

end behavioral;
