----------------------------------------------------------------------------------
-- This block was autogenerated with axis.py
-- If you want to change number of ports, use:
-- python axis.py create concat 'entity name' '# of ports'
----------------------------------------------------------------------------------
library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;
library expert;
	use expert.std_logic_expert.all;

entity axis_intercon is
    generic (
    tdata_size   : integer := 8;
    tdest_size   : integer := 8;
    tuser_size   : integer := 8;
    select_auto  : boolean := false;
    switch_tlast : boolean := false;
    max_tx_size  : integer := 10
    );
    port (
      --general
      clk_i       : in  std_logic;
      rst_i       : in  std_logic;
      --python port code
    );
end axis_intercon;

architecture behavioral of axis_intercon is

  --python constant code

  component axis_switch is
      generic (
        tdata_size   : integer := 8;
        tdest_size   : integer := 8;
        tuser_size   : integer := 8;
        select_auto  : boolean := false;
        switch_tlast : boolean := false;
        max_tx_size  : integer := 10
      );
      port (
        --general
        clk_i       : in  std_logic;
        rst_i       : in  std_logic;
        --component slaves port code
        --AXIS Master port
        m_tdata_o    : out std_logic_vector(tdata_size-1 downto 0);
        m_tuser_o    : out std_logic_vector(tuser_size-1 downto 0);
        m_tdest_o    : out std_logic_vector(tdest_size-1 downto 0);
        m_tready_i   : in  std_logic;
        m_tvalid_o   : out std_logic;
        m_tlast_o    : out std_logic
      );
  end component;

  type axi_tdata_array is array (natural range <>) of std_logic_vector(tdata_size-1 downto 0);
  type axi_tuser_array is array (natural range <>) of std_logic_vector(tuser_size-1 downto 0);
  type axi_tdest_array is array (natural range <>) of std_logic_vector(tdest_size-1 downto 0);

  type axi_signal_array is array (natural range <>) of std_logic_vector(number_slaves-1 downto 0);

  signal s_tdata_s  : axi_tdata_array(number_slaves-1 downto 0);
  signal s_tuser_s  : axi_tuser_array(number_slaves-1 downto 0);
  signal s_tdest_s  : axi_tdest_array(number_slaves-1 downto 0);
  signal s_tvalid_s : std_logic_vector(number_slaves-1 downto 0);
  signal s_tlast_s  : std_logic_vector(number_slaves-1 downto 0);
  signal s_tready_s : std_logic_vector(number_slaves-1 downto 0);

  signal m_tdata_s  : axi_tdata_array(number_masters-1 downto 0);
  signal m_tuser_s  : axi_tuser_array(number_masters-1 downto 0);
  signal m_tdest_s  : axi_tdest_array(number_masters-1 downto 0);
  signal m_tvalid_s : std_logic_vector(number_masters-1 downto 0);
  signal m_tlast_s  : std_logic_vector(number_masters-1 downto 0);
  signal m_tready_s : std_logic_vector(number_masters-1 downto 0);

  signal valid_array_s : axi_signal_array(number_masters-1 downto 0);
  signal ready_array_s : axi_signal_array(number_masters-1 downto 0);

begin

    --array connections

  valid_master_gen : for j in number_masters-1 downto 0 generate
    valid_slave_gen : for k in number_masters-1 downto 0 generate
      valid_array_s(j)(k) <= s_tvalid_s(k) when to_integer(s_tdest_s(j)) = j else '0';
    end generate;
  end generate;

  ready_slave_gen : for k in number_masters-1 downto 0 generate
    s_tready_s(j) <= valid_ready_s(to_integer(s_tdest_s(j)))(j);
  end generate;

  ack_gen : for j in number_masters-1 downto 0 generate

      axis_switch_u : axis_switch
        generic map (
          tdata_size   => tdata_size,
          tdest_size   => tdest_size,
          tuser_size   => tuser_size,
          select_auto  => select_auto,
          switch_tlast => switch_tlast,
          max_tx_size  => max_tx_size
        )
        port map (
          clk_i      => clk_i,
          rst_i      => rst_i,
          --switch instance slaves
          m_tdata_o  => m_tdata_s(j),
          m_tuser_o  => m_tuser_s(j),
          m_tdest_o  => m_tdest_s(j),
          m_tready_i => m_tready_s(j),
          m_tvalid_o => m_tvalid_s(j),
          m_tlast_o  => m_tlast_s(j)
        );

    end generate;

end behavioral;
